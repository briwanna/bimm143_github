---
title: "Class 12"
author: "Brianna Smith"
format: pdf
---

# RNAseq Analysis

The data for this hands-on session comes from a published RNA-seq experiment where airway smooth muscle cells were treated with dexamethasone, a synthetic glucocorticoid steroid with anti-inflammatory effects (Himes et al. 2014).

#Import the data

Begin a new R script and use the read.csv() function to read these count data and metadata files.

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

Now, take a look at each.

```{r}
head(counts)
```



> Q1. How many genes are in this dataset? 

```{r}
nrow(counts)
```

> Q2. How many ‘control’ cell lines do we have? 

4


```{r}
ncol(counts)
```


```{r}
head(metadata)
```

Let's make sure that the id column of the metadata match the order of the counts data

```{r}
metadata$id == colnames(counts)
```


We can use the all function to check `all()` it's inputs are true
```{r}
!all(c(T,T,T,F))
```

```{r}
all(metadata$id == colnames(counts))
```

# Analysis by Hand

```{r}
metadata
```
library(dplyr)
control <- metadata %>% filter(dex=="control")
control.counts <- counts %>% select(control$id) 
control.mean <- rowSums(control.counts)/4
head(control.mean)

> Q3. How would you make the above code in either approach more robust?

Let's first extract our counts for control samples as i want to compare this to our counts fro treated (i.e with drug) samples.

```{r}
control.inds <- metadata$dex == "control"
control.ids <- metadata$id[control.inds]
control.counts <- counts[, control.ids]
head(control.counts)
```

I want a summary counts value for each gene in the control experiments. I will start by taking the average. 
```{r}
#apply(control.counts, 1, mean)
control.mean <- rowMeans(control.counts)
```


> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

Now do the same for the treated.
```{r}
treated.inds <- metadata$dex == "treated"
treated.ids <- metadata$id[treated.inds]
treated.counts <- counts[, treated.ids]
head(treated.counts)
```

```{r}
#apply(treated.counts, 1, mean)
treated.mean <- rowMeans(treated.counts)
```

To help us stay organized let's make a new data.frame to store these results together.
```{r}
meancounts <- data.frame(control.mean, treated.mean)
head(meancounts)
```

> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

And make a wee plot to see how we are doing.

```{r}
plot(meancounts$control.mean, meancounts$treated.mean)
```
>Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot? 

```{r}
library(ggplot2)
ggplot(meancounts, aes(meancounts$control.mean, meancounts$treated.mean)) + geom_point()
```


point

>Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this? 

log

This screams for a log transformation
```{r}
plot(meancounts$control.mean, meancounts$treated.mean, log="xy")
```

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```


> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

arr.ind tells the `which()` function to return wherever there is a true value. The `unique()` functions allows for repeated zero values to be counted only once so that there are no duplicates.


The most useful and most straightforward to understand is log2 transform.

```{r}
log2(20/20)
```

Doubling
```{r}
log2(40/20)
```

Half
```{r}
log2(10/20)
```

```{r}
log2(80/20)
```

add a "log2 fold-change"

```{r}
meancounts$log2fc <- log2(meancounts$treated.mean/meancounts$control.mean)
```

```{r}
head(meancounts)
```


Hmm... we need to get rid of the genes where we have no count data as taking the log 2 of these 0 counts does not tell us anything.

```{r}
to.keep <- rowSums(meancounts[,1:2] == 0) == 0

mycounts <- meancounts[to.keep,]
head(mycounts)
```

```{r}
nrow(mycounts)
```
> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 

314

How many genes are up regulated at the log2fc level of +2 
```{r}
sum(mycounts$log2fc>= +2)
```
> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

485

and down regulated...
```{r}
sum(mycounts$log2fc <= -2)
```

> Q10. Do you trust these results? Why or why not? 

We do not trust these results because we don't know if the change is consistent and significant. 
We are missing stats. Are these big changes significant?

# DESeq2 Analysis

```{r}
#| message: false
library(DESeq2)
```

Like most biocmanager packages DESeq wants it's input in a very specific format.
```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design = ~dex)
dds
```
The main DESeq function is called DESeq

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
head(res)
```

##Volcano Plots

A major summary figure of this type of analysis is called a volcano plot- the idea here is to keep our inner biologist and inner stats person happy with one cool plot!

```{r}
plot(res$log2FoldChange, res$padj)
```

Improve this plot by taking the log of the p-value axis

```{r}
plot(res$log2FoldChange, log(res$padj))
```

I want to flip the y-axis so the values I care about (i.e the low p-value or high log(p-values)) are at the top of the axis

```{r}
plot(res$log2FoldChange, -log(res$padj))
```

Let's finish up for today by adding some color to better highlight the subset of genes that we will focus on next today - i.e. those with big log2fc values (at +2/-2 threshold) and significant p-values (less than 0.5 for example).

```{r}
mycols <- rep("gray", nrow(res))
mycols [abs(res$log2FoldChange) >= 2] <- "purple"
mycols[res$padj <0.05] <- "gray"
```

```{r}
plot(res$log2FoldChange, -log(res$padj), col=mycols)
```

```{r}
plot(res$log2FoldChange, -log(res$padj), col=mycols)
abline(v=c(-2,2), lty=2)
```

## Gene Annotation 

We will use one of Bioconductor's main annotation package to help with mapping between various ID schemes. Here we load the `AnnotationDbi` package and the annotation ata package for humans `org.Hs.eg.db`.

```{r}
head(res)
#rownames(res)
```

```{r}
library(AnnotationDbi)
library(org.Hs.eg.db)
```

Look at what types of IDs I can translate from the `org.Hs.eg.db` packages with the `columns()` function.

```{r}
columns(org.Hs.eg.db)
```

```{r}
res$symbol <- mapIds(x=org.Hs.eg.db, column = "SYMBOL", keys = rownames(res), keytype = "ENSEMBL")
```

and do the same for ENTREZID and GENENAME
```{r}
res$entrez <- mapIds(x= org.Hs.eg.db, column = "ENTREZID", keys = row.names(res), keytype = "ENSEMBL", multiVals = "first")
res$uniprot <- mapIds(x= org.Hs.eg.db, column = "UNIPROT", keys = row.names(res), keytype = "ENSEMBL", multiVals = "first")
res$genename <- mapIds(x= org.Hs.eg.db, column = "GENENAME", keys = row.names(res), keytype = "ENSEMBL", multiVals = "first")
```

```{r}
head(res)
```
## Pathway Analysis

We will finish this lab with a quick pathway analysis. Here we play with just one, the **GAGE package** (which stands for Generally Applicable Gene set Enrichment), to do **KEGG pathway enrichment analysis** 

```{r}
library(pathview)
library(gage)
library(gageData)

data(kegg.sets.hs)

# Examine the first 2 pathways in this kegg set for humans
head(kegg.sets.hs, 2)
```

The main `gage()` function requires a named vector of fold changes, where the names of the values are the Entrez gene IDs.

```{r}
c(barry=4, clair=3, chandra=2)
```

```{r}
foldchanges <- res$log2FoldChange
names(foldchanges) <- res$entrez

head(foldchanges)
```

Now, let's run the gage pathway analysis.

```{r}
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

Now, let's look at the object returned from `gage()` i.e. our results here:

```{r}
attributes(keggres)
```

```{r}
head(keggres$less, 3)
```
Let's pulls up the highlighted pathways and show our differently expressed genes on the pathway. i will use the "hsa" KEGG id to get the pathway from KEGG and my `folgchange` vector to show my genes. 

```{r}
pathview(gene.data = foldchanges, pathway.id = "hsa05310")
```

Put this into my document.

![The Asthma pathway with my highlighted differentially expressed genes in color](hsa05310.pathview.png)


















